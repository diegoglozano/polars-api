{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"polars-api","text":"<p>Polars extension for dealing with REST APIs</p>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#api.Api","title":"<code>Api</code>","text":"Source code in <code>polars_api/api.py</code> <pre><code>@pl.api.register_expr_namespace(\"api\")\nclass Api:\n    def __init__(self, url: pl.Expr) -&gt; None:\n        \"\"\"\n        Initialize the Api class with a URL expression.\n\n        Parameters\n        ----------\n        url : pl.Expr\n            The URL expression.\n        \"\"\"\n        self._url = url\n\n    @staticmethod\n    def _get(url: str, params: Optional[dict[str, str]] = None, timeout: Optional[float] = None) -&gt; Optional[str]:\n        \"\"\"\n        Perform a synchronous GET request.\n\n        Parameters\n        ----------\n        url : str\n            The URL to send the GET request to.\n        params : dict[str, str], optional\n            The query parameters to include in the request.\n        timeout : float, optional\n            The timeout for the request.\n\n        Returns\n        -------\n        str or None\n            The response text if the request is successful, None otherwise.\n        \"\"\"\n        result = httpx.get(url, params=params, timeout=timeout)\n        if _check_status_code(result.status_code):\n            return result.text\n        else:\n            return None\n\n    @staticmethod\n    def _post(url: str, params: dict[str, str], body: str, timeout: float) -&gt; Optional[str]:\n        \"\"\"\n        Perform a synchronous POST request.\n\n        Parameters\n        ----------\n        url : str\n            The URL to send the POST request to.\n        params : dict[str, str]\n            The query parameters to include in the request.\n        body : str\n            The JSON body to include in the request.\n        timeout : float\n            The timeout for the request.\n\n        Returns\n        -------\n        str or None\n            The response text if the request is successful, None otherwise.\n        \"\"\"\n        result = httpx.post(url, params=params, json=body, timeout=timeout)\n        if _check_status_code(result.status_code):\n            return result.text\n        else:\n            return None\n\n    @staticmethod\n    async def _aget_one(url: str, params: str, timeout: float) -&gt; str:\n        \"\"\"\n        Perform an asynchronous GET request.\n\n        Parameters\n        ----------\n        url : str\n            The URL to send the GET request to.\n        params : str\n            The query parameters to include in the request.\n        timeout : float\n            The timeout for the request.\n\n        Returns\n        -------\n        str\n            The response text.\n        \"\"\"\n        async with httpx.AsyncClient() as client:\n            r = await client.get(url, params=params, timeout=timeout)\n            return r.text\n\n    async def _aget_all(self, x, params, timeout):\n        \"\"\"\n        Perform multiple asynchronous GET requests.\n\n        Parameters\n        ----------\n        x : list\n            List of URLs to send the GET requests to.\n        params : list\n            List of query parameters for each request.\n        timeout : float\n            The timeout for the requests.\n\n        Returns\n        -------\n        list\n            List of response texts.\n        \"\"\"\n        return await asyncio.gather(*[self._aget_one(url, param, timeout) for url, param in zip(x, params)])\n\n    def _aget(self, x, params, timeout):\n        \"\"\"\n        Wrapper for performing multiple asynchronous GET requests.\n\n        Parameters\n        ----------\n        x : list\n            List of URLs to send the GET requests to.\n        params : list\n            List of query parameters for each request.\n        timeout : float\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Series\n            Series of response texts.\n        \"\"\"\n        return pl.Series(asyncio.run(self._aget_all(x, params, timeout)))\n\n    @staticmethod\n    async def _apost_one(url: str, params: str, body: str, timeout: Optional[float]) -&gt; str:\n        \"\"\"\n        Perform an asynchronous POST request.\n\n        Parameters\n        ----------\n        url : str\n            The URL to send the POST request to.\n        params : str\n            The query parameters to include in the request.\n        body : str\n            The JSON body to include in the request.\n        timeout : float, optional\n            The timeout for the request.\n\n        Returns\n        -------\n        str\n            The response text.\n        \"\"\"\n        async with httpx.AsyncClient() as client:\n            r = await client.post(url, params=params, json=body, timeout=timeout)\n            return r.text\n\n    async def _apost_all(self, x, params, body, timeout):\n        \"\"\"\n        Perform multiple asynchronous POST requests.\n\n        Parameters\n        ----------\n        x : list\n            List of URLs to send the POST requests to.\n        params : list\n            List of query parameters for each request.\n        body : list\n            List of JSON bodies for each request.\n        timeout : float\n            The timeout for the requests.\n\n        Returns\n        -------\n        list\n            List of response texts.\n        \"\"\"\n        return await asyncio.gather(*[\n            self._apost_one(url, _params, _body, timeout) for url, _params, _body in zip(x, params, body)\n        ])\n\n    def _apost(self, x, params, body, timeout):\n        \"\"\"\n        Wrapper for performing multiple asynchronous POST requests.\n\n        Parameters\n        ----------\n        x : list\n            List of URLs to send the POST requests to.\n        params : list\n            List of query parameters for each request.\n        body : list\n            List of JSON bodies for each request.\n        timeout : float\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Series\n            Series of response texts.\n        \"\"\"\n        return pl.Series(asyncio.run(self._apost_all(x, params, body, timeout)))\n\n    def get(self, params: Optional[pl.Expr] = None, timeout: Optional[float] = None) -&gt; pl.Expr:\n        \"\"\"\n        Perform a synchronous GET request for each URL in the expression.\n\n        Parameters\n        ----------\n        params : pl.Expr, optional\n            The query parameters expression.\n        timeout : float, optional\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Expr\n            Expression containing the response texts.\n        \"\"\"\n        if params is None:\n            params = pl.lit(None)\n        return pl.struct(self._url.alias(\"url\"), params.alias(\"params\")).map_elements(\n            lambda x: self._get(x[\"url\"], params=x[\"params\"], timeout=timeout),\n            return_dtype=pl.Utf8,\n        )\n\n    def post(\n        self, params: Optional[pl.Expr] = None, body: Optional[pl.Expr] = None, timeout: Optional[float] = None\n    ) -&gt; pl.Expr:\n        \"\"\"\n        Perform a synchronous POST request for each URL in the expression.\n\n        Parameters\n        ----------\n        params : pl.Expr, optional\n            The query parameters expression.\n        body : pl.Expr, optional\n            The JSON body expression.\n        timeout : float, optional\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Expr\n            Expression containing the response texts.\n        \"\"\"\n        if params is None:\n            params = pl.lit(None)\n        if body is None:\n            body = pl.lit(None)\n        return pl.struct(self._url.alias(\"url\"), params.alias(\"params\"), body.alias(\"body\")).map_elements(\n            lambda x: self._post(x[\"url\"], params=x[\"params\"], body=x[\"body\"], timeout=timeout),\n            return_dtype=pl.Utf8,\n        )\n\n    def aget(self, params: Optional[pl.Expr] = None, timeout: Optional[float] = None) -&gt; pl.Expr:\n        \"\"\"\n        Perform an asynchronous GET request for each URL in the expression.\n\n        Parameters\n        ----------\n        params : pl.Expr, optional\n            The query parameters expression.\n        timeout : float, optional\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Expr\n            Expression containing the response texts.\n        \"\"\"\n        nest_asyncio.apply()\n        if params is None:\n            params = pl.lit(None)\n        return pl.struct(self._url.alias(\"url\"), params.alias(\"params\")).map_batches(\n            lambda x: self._aget(x.struct.field(\"url\"), params=x.struct.field(\"params\"), timeout=timeout)\n        )\n\n    def apost(\n        self, params: Optional[pl.Expr] = None, body: Optional[pl.Expr] = None, timeout: Optional[float] = None\n    ) -&gt; pl.Expr:\n        \"\"\"\n        Perform an asynchronous POST request for each URL in the expression.\n\n        Parameters\n        ----------\n        params : pl.Expr, optional\n            The query parameters expression.\n        body : pl.Expr, optional\n            The JSON body expression.\n        timeout : float, optional\n            The timeout for the requests.\n\n        Returns\n        -------\n        pl.Expr\n            Expression containing the response texts.\n        \"\"\"\n        nest_asyncio.apply()\n        if params is None:\n            params = pl.lit(None)\n        if body is None:\n            body = pl.lit(None)\n        return pl.struct(self._url.alias(\"url\"), params.alias(\"params\"), body.alias(\"body\")).map_batches(\n            lambda x: self._apost(\n                x.struct.field(\"url\"), params=x.struct.field(\"params\"), body=x.struct.field(\"body\"), timeout=timeout\n            )\n        )\n</code></pre>"},{"location":"documentation/#api.Api.__init__","title":"<code>__init__(url)</code>","text":"<p>Initialize the Api class with a URL expression.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Expr</code> <p>The URL expression.</p> required Source code in <code>polars_api/api.py</code> <pre><code>def __init__(self, url: pl.Expr) -&gt; None:\n    \"\"\"\n    Initialize the Api class with a URL expression.\n\n    Parameters\n    ----------\n    url : pl.Expr\n        The URL expression.\n    \"\"\"\n    self._url = url\n</code></pre>"},{"location":"documentation/#api.Api.aget","title":"<code>aget(params=None, timeout=None)</code>","text":"<p>Perform an asynchronous GET request for each URL in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Expr</code> <p>The query parameters expression.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the requests.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Expression containing the response texts.</p> Source code in <code>polars_api/api.py</code> <pre><code>def aget(self, params: Optional[pl.Expr] = None, timeout: Optional[float] = None) -&gt; pl.Expr:\n    \"\"\"\n    Perform an asynchronous GET request for each URL in the expression.\n\n    Parameters\n    ----------\n    params : pl.Expr, optional\n        The query parameters expression.\n    timeout : float, optional\n        The timeout for the requests.\n\n    Returns\n    -------\n    pl.Expr\n        Expression containing the response texts.\n    \"\"\"\n    nest_asyncio.apply()\n    if params is None:\n        params = pl.lit(None)\n    return pl.struct(self._url.alias(\"url\"), params.alias(\"params\")).map_batches(\n        lambda x: self._aget(x.struct.field(\"url\"), params=x.struct.field(\"params\"), timeout=timeout)\n    )\n</code></pre>"},{"location":"documentation/#api.Api.apost","title":"<code>apost(params=None, body=None, timeout=None)</code>","text":"<p>Perform an asynchronous POST request for each URL in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Expr</code> <p>The query parameters expression.</p> <code>None</code> <code>body</code> <code>Expr</code> <p>The JSON body expression.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the requests.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Expression containing the response texts.</p> Source code in <code>polars_api/api.py</code> <pre><code>def apost(\n    self, params: Optional[pl.Expr] = None, body: Optional[pl.Expr] = None, timeout: Optional[float] = None\n) -&gt; pl.Expr:\n    \"\"\"\n    Perform an asynchronous POST request for each URL in the expression.\n\n    Parameters\n    ----------\n    params : pl.Expr, optional\n        The query parameters expression.\n    body : pl.Expr, optional\n        The JSON body expression.\n    timeout : float, optional\n        The timeout for the requests.\n\n    Returns\n    -------\n    pl.Expr\n        Expression containing the response texts.\n    \"\"\"\n    nest_asyncio.apply()\n    if params is None:\n        params = pl.lit(None)\n    if body is None:\n        body = pl.lit(None)\n    return pl.struct(self._url.alias(\"url\"), params.alias(\"params\"), body.alias(\"body\")).map_batches(\n        lambda x: self._apost(\n            x.struct.field(\"url\"), params=x.struct.field(\"params\"), body=x.struct.field(\"body\"), timeout=timeout\n        )\n    )\n</code></pre>"},{"location":"documentation/#api.Api.get","title":"<code>get(params=None, timeout=None)</code>","text":"<p>Perform a synchronous GET request for each URL in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Expr</code> <p>The query parameters expression.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the requests.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Expression containing the response texts.</p> Source code in <code>polars_api/api.py</code> <pre><code>def get(self, params: Optional[pl.Expr] = None, timeout: Optional[float] = None) -&gt; pl.Expr:\n    \"\"\"\n    Perform a synchronous GET request for each URL in the expression.\n\n    Parameters\n    ----------\n    params : pl.Expr, optional\n        The query parameters expression.\n    timeout : float, optional\n        The timeout for the requests.\n\n    Returns\n    -------\n    pl.Expr\n        Expression containing the response texts.\n    \"\"\"\n    if params is None:\n        params = pl.lit(None)\n    return pl.struct(self._url.alias(\"url\"), params.alias(\"params\")).map_elements(\n        lambda x: self._get(x[\"url\"], params=x[\"params\"], timeout=timeout),\n        return_dtype=pl.Utf8,\n    )\n</code></pre>"},{"location":"documentation/#api.Api.post","title":"<code>post(params=None, body=None, timeout=None)</code>","text":"<p>Perform a synchronous POST request for each URL in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Expr</code> <p>The query parameters expression.</p> <code>None</code> <code>body</code> <code>Expr</code> <p>The JSON body expression.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout for the requests.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Expression containing the response texts.</p> Source code in <code>polars_api/api.py</code> <pre><code>def post(\n    self, params: Optional[pl.Expr] = None, body: Optional[pl.Expr] = None, timeout: Optional[float] = None\n) -&gt; pl.Expr:\n    \"\"\"\n    Perform a synchronous POST request for each URL in the expression.\n\n    Parameters\n    ----------\n    params : pl.Expr, optional\n        The query parameters expression.\n    body : pl.Expr, optional\n        The JSON body expression.\n    timeout : float, optional\n        The timeout for the requests.\n\n    Returns\n    -------\n    pl.Expr\n        Expression containing the response texts.\n    \"\"\"\n    if params is None:\n        params = pl.lit(None)\n    if body is None:\n        body = pl.lit(None)\n    return pl.struct(self._url.alias(\"url\"), params.alias(\"params\"), body.alias(\"body\")).map_elements(\n        lambda x: self._post(x[\"url\"], params=x[\"params\"], body=x[\"body\"], timeout=timeout),\n        return_dtype=pl.Utf8,\n    )\n</code></pre>"}]}